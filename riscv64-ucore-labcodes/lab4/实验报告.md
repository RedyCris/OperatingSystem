

## 练习1：分配并初始化一个进程控制块

### 关键字段说明
在 `alloc_proc` 函数中，先初始化了以下变量：

- `state`：设置为 `PROC_UNINIT`，表示设置进程为“初始”态。
- `pid`：设置为 `-1`，表示进程ID尚未分配。
- `cr3`：设置为 `boot_cr3`，指向启动时的页目录表基地址。
- `runs`：初始化为 `0`，表示进程尚未运行。
- `kstack`：初始化为 `0`，表示内核栈尚未分配。
- `need_resched`：初始化为 `0`，表示当前进程不需要重新调度。
- `parent` 和 `mm`：初始化为 `NULL`，表示当前进程没有父进程和内存管理结构。
- `tf`：初始化为 `NULL`，表示当前进程没有关联的中断帧。
- `context` 和 `name`：使用 `memset` 初始化为零。

### 代码实现
以下是 `alloc_proc` 函数的代码实现：

```c
static struct proc_struct *
alloc_proc(void) {
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL) {
        proc->state = PROC_UNINIT;
        proc->pid = -1;
        proc->cr3 = boot_cr3;

        proc->runs = 0;
        proc->kstack = 0;
        proc->need_resched = 0;
        proc->parent = NULL;
        proc->mm = NULL;
        proc->tf = NULL;
        proc->flags = 0;
        
        memset(&(proc->context), 0, sizeof(struct context));
        memset(&(proc->name), 0, PROC_NAME_LEN);
    }
    return proc;
}
```

### proc_struct中 `struct context context` 和 `struct trapframe *tf` 成员变量含义和在本实验中的作用

#### `struct context context` 含义

`struct context` 结构体用于保存进程的执行上下文信息。它包含了多个寄存器的值，包括返回地址（`ra`）、栈指针（`sp`）以及其他保存寄存器（`s0` 到 `s11`）的值。它们允许操作系统在不同进程之间切换时，能够保存和恢复每个进程的状态。

#### 在本实验中的作用

在 `proc_run` 函数中，`switch_to(&(prev->context), &(next->context));` 这一行代码实现了进程的上下文切换。具体来说：

- `prev` 代表当前正在运行的进程，而 `next` 是即将被调度的进程。
- `switch_to` 函数会保存当前进程的上下文（即 `prev->context`），并加载下一个进程的上下文（即 `next->context`）。
- 通过这种方式，操作系统能够在进程之间切换，而不会丢失任何进程的执行状态。

在 `copy_thread` 函数中，`proc->context.ra` 和 `proc->context.sp` 被设置为 `forkret` 和 `proc->tf` 的地址，分别指向进程返回的地址和当前进程的中断帧。这确保了新创建的进程在被调度时能够从正确的位置继续执行。

####  `struct trapframe *tf` 含义

`struct trapframe` 结构体用于保存进程在发生中断或异常时的状态。它包含了通用寄存器（`gpr`）、状态寄存器（`status`）、异常程序计数器（`epc`）、异常值（`tval`）和异常原因（`cause`）等信息。它们允许操作系统恢复到中断发生前的状态。

#### 在本实验中的作用

在 `copy_thread` 函数中，`proc->tf` 被初始化为当前进程的内核栈顶部，并将传入的 `tf` 的内容复制到 `proc->tf` 中。这一过程确保了新进程在被调度时能够正确响应中断或异常。具体来说：

- `proc->tf->gpr.a0` 被设置为 `0`，说明这个进程是一个子进程。
- `proc->tf->gpr.sp` 被设置为当前的栈指针，确保新进程在执行时能够正确使用栈。
- `proc->context.sp` 被设置为 `proc->tf` 的地址，确保在上下文切换时能够正确恢复栈指针。