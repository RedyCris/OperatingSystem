# lab5实验报告

---

## 实验要求
**了解第一个用户进程创建过程**

**了解系统调用框架的实现机制**

**了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理**

---
## 实验内容
### 练习1：加载应用程序并执行（需要编程）
do_execve 函数调用 load_icode （位于kern/process/proc.c中）来加载并解析一个处于内存
中的ELF执行文件格式的应用程序。你需要补充 load_icode 的第6步，建立相应的用户内存空间来放置
应用程序的代码段、数据段等，且要设置好 proc_struct 结构中的成员变量trapframe中的内容，确保
在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。




实现 `load_icode` 的第 6 步主要目的是初始化用户进程的 `trapframe`，确保从内核态切换到用户态时，用户程序能够从正确的入口地址开始执行，同时能正常处理中断。以下是实现步骤的详细讲解：

---


#### 1. 获取当前进程的 `trapframe`

`trapframe` 是一个保存用户程序上下文的结构体，切换到用户态时 CPU 的寄存器状态由 `trapframe` 指定。

```c
struct trapframe *tf = current->tf;
```

通过 `current->tf` 获取当前进程的 `trapframe`。

---

#### 2. 保存当前状态寄存器 `sstatus`

在设置 `trapframe` 之前，需要保存当前 `sstatus`，以便保留特定的位状态。例如，中断状态需要保留。

```c
uintptr_t sstatus = tf->status;
```

---

#### 3. 初始化 `trapframe`

为了避免遗留无关数据，首先清空 `trapframe`。

```c
memset(tf, 0, sizeof(struct trapframe));
```

---

#### 4. 设置用户栈指针 (`gpr.sp`)

用户程序需要一个独立的栈，用于存储函数调用和局部变量。通常，用户栈顶地址由操作系统定义为 `USTACKTOP`。

```c
tf->gpr.sp = USTACKTOP;
```

这里 `USTACKTOP` 是用户栈的顶端地址，`gpr.sp` 应指向该地址。

---

#### 5. 设置程序入口地址 (`epc`)

用户程序入口地址存储在 ELF 文件头部的 `e_entry` 字段中。将 `epc` 设置为该地址，确保用户程序从正确的入口开始执行。

```c
tf->epc = elf->e_entry;
```

---

#### 6. 配置状态寄存器 (`status`)

状态寄存器 `status` 决定了程序的运行模式和中断状态：

1. **清除 `SPP` 位：**
   - `SPP` (Previous Privilege Level) 表示上一次运行的特权级。
   - 设置为 0 表示返回用户态。

2. **设置 `SPIE` 位：**
   - `SPIE` (Supervisor Interrupt Enable) 表示中断是否启用。
   - 设置为 1 表示启用中断。

具体实现如下：

```c
tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
```

- `~SSTATUS_SPP`：清除 `SPP` 位。
- `| SSTATUS_SPIE`：设置 `SPIE` 位。



#### 用户态进程从被 uCore 选择到具体执行应用程序第一条指令的过程

1. **进程调度 (Scheduling):**
   - 调度器在多个进程中选择一个处于可运行态（`RUNNABLE`）的进程。
   - 被选择的进程状态从 `RUNNABLE` 转为 `RUNNING`，即获得 CPU 的占用权。

2. **切换到新进程的上下文 (Context Switch):**
   - 调度器保存当前运行进程的上下文（包括寄存器内容和 `trapframe`）。
   - 从被选中进程的 `proc_struct` 中恢复其 `trapframe` 到 CPU 寄存器，确保新进程能够正确运行。

3. **设置特权级和栈 (Privilege and Stack Setup):**
   - `trapframe` 中的 `gpr.sp` 指定用户栈指针，CPU 会指向用户态栈顶。
   - `status` 寄存器中的 `SPP` 设置为用户态，`SPIE` 使能中断。

4. **加载用户态程序计数器 (Program Counter):**
   - 调度器将 `trapframe` 的 `epc` 值加载到 `sepc`（Supervisor Exception Program Counter）寄存器。
   - 该值是用户程序的入口地址（`elf->e_entry`），指向应用程序第一条指令。

5. **从内核态返回用户态 (Return to User Mode):**
   - 通过 RISC-V 的 `sret` 指令，CPU 切换到用户态：
     - 恢复用户模式下的 `status` 和 `sepc`。
     - 跳转到用户程序入口地址。

6. **用户程序执行:**
   - CPU 开始从 `sepc` 指定的地址（`epc`）执行应用程序的第一条指令。
   - 进程正式进入用户态运行，处理用户级逻辑。

---






### 练习2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。




`copy_range` 的作用是在创建子进程时，复制父进程的用户内存地址空间中的合法内容到子进程。以下是具体的实现步骤与讲解：


#### 1. 输入参数的检查

确保地址范围是按页对齐的，同时范围在用户空间内：

```c
assert(start % PGSIZE == 0 && end % PGSIZE == 0);
assert(USER_ACCESS(start, end));
```

- `PGSIZE`：定义了每页的大小，通常是 4KB。
- `USER_ACCESS`：检查地址是否属于用户空间。

---

#### 2. 遍历地址空间，逐页处理

使用 `do-while` 循环，从 `start` 到 `end` 遍历地址空间：

```c
do {
    // 根据地址获取源页表项（父进程的页表）
    pte_t *ptep = get_pte(from, start, 0), *nptep;
    if (ptep == NULL) {
        // 若当前页表不存在，跳到下一段
        start = ROUNDDOWN(start + PTSIZE, PTSIZE);
        continue;
    }
```

- 调用 `get_pte` 获取父进程页表中的页表项 (`pte`)。
- 若 `pte` 为 `NULL`，说明对应页不存在，直接跳过。

---

#### 3. 检查页表项合法性

如果页表项有效 (`PTE_V`)，说明此页存在并有效：

```c
if (*ptep & PTE_V) {
    // 获取目标页表项（子进程的页表）
    if ((nptep = get_pte(to, start, 1)) == NULL) {
        return -E_NO_MEM; // 无法分配页表时返回错误
    }

    uint32_t perm = (*ptep & PTE_USER); // 提取权限
    struct Page *page = pte2page(*ptep); // 获取源页面
    struct Page *npage = alloc_page();   // 分配新页面
    assert(page != NULL);
    assert(npage != NULL);
```

- `PTE_V`：页表项有效位，表示该页存在。
- `PTE_USER`：获取用户级权限，确保用户进程可以访问。
- `pte2page`：从页表项中获取源页面指针。
- `alloc_page`：为子进程分配一个新页面。

---

#### 4. 判断是否共享页面 (`share`)

根据 `share` 参数决定是共享页面（写时复制）还是复制页面内容：

**(1) 共享页面：**

```c
if (share) {
    // 映射共享页面，子进程和父进程共享该页面，禁止写操作
    page_insert(from, page, start, perm & (~PTE_W));
    ret = page_insert(to, page, start, perm & (~PTE_W));
} 
```

- 将子进程和父进程共享页面，并禁止写操作（通过清除 `PTE_W` 位实现）。
- 写时复制可以节省内存，只有在需要写入时才会分配新页面。

**(2) 复制页面内容：**

```c
else {
    // 获取源页面和目标页面的内核虚拟地址
    void *src_kvaddr = page2kva(page);
    void *dst_kvaddr = page2kva(npage);

    // 将源页面内容复制到目标页面
    memcpy(dst_kvaddr, src_kvaddr, PGSIZE);

    // 建立目标页面的映射
    ret = page_insert(to, npage, start, perm);
}
```

- `page2kva`：获取页面对应的内核虚拟地址。
- `memcpy`：将源页面内容复制到目标页面，大小为一页 (`PGSIZE`)。
- `page_insert`：将目标页面插入子进程的页表，建立线性地址和物理地址的映射。

---

#### 5. 更新地址并继续下一页

```c
start += PGSIZE;
return 0;
```

将 `start` 地址增加一页大小，继续处理下一页。

---

#### 如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。

**Copy on Write（COW）** 是一种优化内存管理的技术，通过延迟对数据的实际复制，仅在数据被修改时才执行真正的拷贝。它广泛应用于进程的 `fork` 操作，能够显著降低资源消耗。

---

### **概要设计**

1. **核心思想：**
   - 父进程与子进程共享页面，页面初始设置为只读。
   - 当进程尝试写入共享页面时，触发页面异常，分配新页面并复制内容，实现按需拷贝。

2. **关键步骤：**
   1. **标记页面为只读共享：**
      - 在 `fork` 时，子进程与父进程共享所有内存页面，并将页面权限设置为只读。
   2. **增加引用计数：**
      - 为每个页面维护引用计数，记录页面被共享的次数。
   3. **写时拷贝：**
      - 当页面被写入时，触发页面异常，判断引用计数：
        - 若引用计数为 1：直接修改权限为可写。
        - 若引用计数 > 1：分配新页面，拷贝原页面数据，并更新页表。

---
### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现
---

#### **1. fork 系统调用**

##### **功能描述**
`fork` 系统调用用于创建一个子进程。调用成功后，父进程和子进程各自运行，父进程返回子进程的 PID，子进程返回 0。




- **`do_fork` 的主要步骤：**
  1. **分配并初始化子进程控制块 (`alloc_proc`)：**
     - 为子进程分配 `proc_struct`。
     - 设置初始状态为 `PROC_UNINIT`。

  2. **分配并初始化内核栈 (`setup_stack`)：**
     - 每个进程拥有独立的内核栈，用于存储内核态的上下文。

  3. **复制内存资源 (`copy_mm`)：**
     - 根据 `clone_flags` 决定内存空间的共享模式（写时复制或完全复制）。
     - 如果启用写时复制，则父子进程共享页面，并设置为只读。

  4. **复制上下文 (`copy_thread`)：**
     - 将父进程的寄存器状态复制到子进程。
     - 设置子进程的返回值为 0（区分父子进程）。

  5. **将子进程加入调度队列：**
     - 将子进程插入全局进程队列（`proc_list` 和 `hash_list`）。
     - 将状态设置为 `PROC_RUNNABLE`，表示可运行。

  6. **返回子进程的 PID：**
     - 父进程中 `do_fork` 返回子进程的 PID。
     - 子进程返回值为 0。

**用户态程序调用sys_fork()系统调用，通过syscall进入内核态**
**内核态处理sys_fork()系统调用，调用do_fork()函数创建子进程，完成后返回到用户态。**
---

#### **2. exec系统调用**

##### **功能描述**
`exec` 系统调用用于加载一个新的程序到当前进程，替换当前进程的用户空间，执行指定的 ELF 文件。




- **`do_execve` 的主要步骤：**
  1. **清空当前进程的用户内存空间：**
     - 如果当前内存管理结构 `mm` 不为空，释放进程占用的用户内存。
     - 通过 `mm_destroy` 清理用户内存空间。

  2. **加载 ELF 文件：**
     - 调用 `load_icode` 解析 ELF 文件。
     - 将 ELF 的代码段、数据段等加载到新的内存空间中。
     - 初始化用户栈并设置程序入口地址。

  3. **设置新的上下文：**
     - 初始化 `trapframe`，设置用户栈指针 (`sp`)、程序入口地址 (`epc`)、用户态状态寄存器 (`sstatus`)。
     - 确保从用户态入口地址开始执行。

**用户态程序调用sys_exec()系统调用，通过syscall进入内核态。**
**内核态处理sys_exec()系统调用，调用do_execve()函数加载新的程序，但由于当前是在S mode下，无法直接进行上下文切换。因此使用ebreak产生断点中断，转发到syscall()函数，在该函数中完成上下文切换，最终返回到用户态。**

---

#### **3. wait 系统调用**

##### **功能描述**
`wait` 系统调用用于等待子进程结束并回收其资源。



- **`do_wait` 的主要步骤：**
  1. **检查子进程状态：**
     - 如果子进程处于 `PROC_ZOMBIE` 状态，立即回收资源并返回。
     - 如果子进程未结束，将当前进程状态设置为 `PROC_SLEEPING`，挂起等待子进程结束。

  2. **回收子进程资源：**
     - 释放子进程占用的内存资源。
     - 从全局进程队列中移除 `proc_struct`。

  3. **唤醒父进程：**
     - 子进程调用 `exit` 后通知父进程，唤醒处于 `WT_CHILD` 状态的父进程。

**用户态程序调用sys_wait()系统调用，通过syscall进入内核态。**
**内核态处理sys_wait()系统调用，调用do_wait()函数等待子进程退出，完成后返回到用户态。**

---

#### **4. exit 系统调用**

##### **功能描述**
`exit` 系统调用用于结束当前进程，释放资源并通知父进程。



- **`do_exit` 的主要步骤：**
  1. **设置进程状态：**
     - 将当前进程状态设置为 `PROC_ZOMBIE`，表示进程已结束但资源未完全回收。
     - 设置退出码 `error_code`。

  2. **释放资源：**
     - 调用 `mm_destroy` 释放用户内存。
     - 释放其他内核资源（如文件描述符等）。

  3. **通知父进程：**
     - 若父进程处于 `WT_CHILD` 状态，唤醒父进程。
     - 如果没有父进程，则将子进程交由 `init` 进程接管。

  4. **调度其他进程：**
     - 调用 `schedule`，从调度队列中选择新的进程运行。

**用户态程序调用sys_exit()系统调用，通过syscall进入内核态。**
**内核态处理sys_exit()系统调用，调用do_exit()函数结束当前进程，最终返回到用户态。**

---

#### **5. uCore 中的进程状态**

##### **状态定义**
uCore 中进程的状态主要包括：
1. **`PROC_UNINIT`：** 进程未初始化。
2. **`PROC_SLEEPING`：** 进程处于休眠状态，等待事件。
3. **`PROC_RUNNABLE`：** 进程可以运行，等待调度。
4. **`PROC_ZOMBIE`：** 进程结束但资源未回收。



##### **状态转换的触发条件**
- `PROC_UNINIT → PROC_RUNNABLE`：`fork` 系统调用。
- `PROC_RUNNABLE → PROC_SLEEPING`：`wait` 或资源等待。
- `PROC_RUNNABLE → PROC_ZOMBIE`：`exit` 系统调用。

---


### 扩展练习 Challenge













#### 实现 Copy on Write



##### **1. 设置共享页面**
在 `fork` 系统调用中，父子进程共享相同的页面，将页面权限设置为只读，并更新页表映射。

```c
if (share) {
    // 将页面权限设置为只读，共享页面
    page_insert(from, page, start, perm & (~PTE_W));
    ret = page_insert(to, page, start, perm & (~PTE_W));
} else {
    // 非共享模式，直接复制页面内容并建立新的映射
    void *src_kvaddr = page2kva(page);
    void *dst_kvaddr = page2kva(npage);
    memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
    ret = page_insert(to, npage, start, perm);
}
```

- **`perm & (~PTE_W)`**：清除写权限，设置页面为只读。
- **`page_insert`**：将页面映射到父进程和子进程的地址空间。

---

##### **2. 写时复制（COW）处理**
当进程尝试写入只读页面时，会触发页面错误中断（PageFault）。根据中断错误码 `error_code` 识别是否是 COW 场景。

```c
else if ((*ptep & PTE_V) && (error_code & 3 == 3)) {
    // 识别写时复制场景：错误码低两位（P=1，W/R=1）
    struct Page *page = pte2page(*ptep);
    struct Page *npage = pgdir_alloc_page(mm->pgdir, addr, perm);
    uintptr_t src_kvaddr = page2kva(page);
    uintptr_t dst_kvaddr = page2kva(npage);
    // 拷贝页面内容到新的物理页面
    memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
    // 建立新的映射，替换原来的只读页面
    page_insert(mm->pgdir, npage, addr, PTE_W | PTE_USER);
}
```

- **`pte2page(*ptep)`**：从页表项获取原页面。
- **`pgdir_alloc_page`**：分配一个新的物理页面。
- **`memcpy(dst_kvaddr, src_kvaddr, PGSIZE)`**：将原页面的内容复制到新页面。
- **`page_insert`**：更新页表，将新页面映射到当前进程。

---

##### **3. 触发页面错误中断**
当进程尝试写入只读页面时，CPU 会触发页面错误（PageFault），错误代码 `error_code` 的最低两位指示访问类型：
- `P=1`：页面存在。
- `W/R=1`：写访问。

例如：
- **`error_code & 3 == 3`**：表示写入共享的只读页面。

---

##### **4. 共享与独立页面管理**
- **共享模式（`share = 1`）：**
  - 父子进程共享页面，引用计数增加。
  - 写操作触发 COW，分配新页面。

- **非共享模式：**
  - 直接在 `fork` 时复制页面，创建独立的页面。

---

#### 实验原理

##### **1. `fork` 过程中设置共享**
在 `fork` 时，通过以下代码实现共享页面的映射：

```c
page_insert(from, page, start, perm & (~PTE_W)); // 父进程只读映射
ret = page_insert(to, page, start, perm & (~PTE_W)); // 子进程只读映射
```

- 父子进程共享页面，权限设置为只读。
- 页表项中没有写权限（`~PTE_W`）。

##### **2. 写时复制逻辑**
当触发写时复制（COW）时：

```c
struct Page *page = pte2page(*ptep);          // 获取原页面
struct Page *npage = pgdir_alloc_page(mm->pgdir, addr, perm); // 分配新页面
uintptr_t src_kvaddr = page2kva(page);        // 原页面虚拟地址
uintptr_t dst_kvaddr = page2kva(npage);       // 新页面虚拟地址
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);       // 复制页面内容
page_insert(mm->pgdir, npage, addr, PTE_W | PTE_USER); // 更新页表映射为可写
```

- 复制页面内容，确保新页面的独立性。
- 更新页表，使当前进程使用新的可写页面。

##### **3. 共享页面的释放**
在进程 `exit` 或页面替换时，检查页面引用计数，决定是否释放物理页面。

---

##### **状态转换（有限状态机）**

以下为 COW 的状态转换图：

```plaintext
+--------------------+        写时复制       +---------------------+
|   页面共享（只读） | --------------------> | 页面独立（可写）     |
| 引用计数 > 1       |                        | 引用计数 = 1         |
+--------------------+                        +---------------------+
       ^                                             |
       |                                             |
       |                    fork                     |
       +---------------------------------------------+
```

**状态说明：**
1. **页面共享（只读）：**
   - 页面引用计数 > 1。
   - 进程共享相同页面，页面权限设置为只读。

2. **页面独立（可写）：**
   - 页面引用计数为 1。
   - 写时复制后，分配新页面并建立新的映射。

---
#### 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？

##### **1. 实验中的用户程序加载机制**

在实验中：
- **加载时机：** 用户程序在调用 `execve` 系统调用时，整个程序就被一次性加载到内存中（包括代码段、数据段等）。
- **执行过程：**
  1. 在内核中，`execve` 调用负责解析 ELF 文件格式。
  2. 将可执行文件的内容（代码段、数据段等）从磁盘读取到内存。
  3. 设置程序的入口地址，并准备好用户栈等。
  4. 当程序进入用户态时，程序就已经完全加载到内存，直接从入口地址开始执行。

这种方式的好处是**简单直接**，程序可以快速开始执行，避免了后续加载的复杂性。

---

##### **2. 常见操作系统中的加载机制**

在实际的操作系统（如 Linux、Windows）中：
- **加载时机：** 用户程序通常在运行时动态加载。
  1. 程序启动时，操作系统只加载程序的必要部分（例如代码段的入口点）。
  2. 其余的代码和数据通常使用按需加载（demand loading）的方式，当需要使用某个部分时才加载到内存。
- **执行过程：**
  1. 启动时只加载必要的程序头信息。
  2. 通过页表、页面缺页中断等机制，按需加载剩余部分。
  3. 程序运行过程中，动态链接器还会加载所需的共享库。

这种方式的好处是**节省内存和启动时间**，因为并不是所有程序的内容都会被立即加载。

---

##### **3. 两种加载方式的区别**

| **特性**                   | **实验中加载方式**                     | **常见操作系统加载方式**           |
|----------------------------|--------------------------------------|----------------------------------|
| **加载时机**               | `execve` 调用时一次性加载              | 运行时按需加载                   |
| **加载内容**               | 程序的所有部分（代码段、数据段等）     | 按需加载需要的代码段和数据段     |
| **内存使用效率**           | 可能加载了未使用的部分，占用更多内存    | 仅加载使用的部分，节省内存       |
| **运行效率**               | 加载完成后执行速度快                  | 动态加载可能带来轻微的性能开销   |
| **实现复杂度**             | 简单，加载逻辑集中在 `execve` 中       | 复杂，涉及页表、缺页中断等机制   |

---

##### **4. 为什么实验中采用预加载？**

实验中选择预加载用户程序的方式是为了**简化实现和执行过程**：
- **简化内核逻辑：** 通过一次性加载整个用户程序，避免了需要处理按需加载时的页面调度、缺页中断等复杂逻辑。
- **加速实验进程：** 用户程序加载完成后可以直接运行，无需在运行时再动态加载。

这种方式虽然简单，但在真实操作系统中并不常用，因为它会浪费内存资源（加载未使用的部分），并且无法动态适应程序运行需求。

