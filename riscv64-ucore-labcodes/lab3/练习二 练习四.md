## 练习2：深入理解不同分页模式的工作原理（思考题）
get_pte() 函数实现了一个用于获取页表项（PTE）的函数 `get_pte()`。在操作系统内核中，地址转换（虚拟地址到物理地址的转换）是通过页表完成的，该函数目的是根据给定的虚拟地址 `la`，从页目录 `pgdir` 中找到相应的页表项。如果页表项不存在且需要创建（由参数 `create` 决定），则会动态分配新的页表项。

### 1. 函数定义

```c
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create)
```

- **参数说明**：
  - `pgdir`: 页目录的虚拟地址。
  - `la`: 需要查询的虚拟地址。
  - `create`: 如果为 `true`，当页表不存在时会创建一个新的页表；如果为 `false`，则只进行查询。
- **返回值**：返回指向页表项（PTE）的指针，如果失败则返回 `NULL`。

### 2. 页表结构

使用两级页表来进行地址转换：
- **第一级页目录**（Page Directory Level 1）：包含多个页目录项（PDE），每个项指向一个二级页表。
- **第二级页目录**（Page Directory Level 0）：包含多个页表项（PTE），每个项指向实际的物理页。

### 3. 代码讲解

#### 第一级页目录查询

```c
pde_t *pdep1 = &pgdir[PDX1(la)];
if (!(*pdep1 & PTE_V)) {
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL) {
        return NULL;
    }
    set_page_ref(page, 1);
    uintptr_t pa = page2pa(page);
    memset(KADDR(pa), 0, PGSIZE);
    *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
}
```

- `pdep1 = &pgdir[PDX1(la)]`：
  - 计算虚拟地址 `la` 对应的第一级页目录项（PDE）的索引，`PDX1(la)` 是一个宏，用于从虚拟地址中提取第一级页目录的索引。
- `if (!(*pdep1 & PTE_V))`：
  - 检查第一级页目录项是否有效（即 `PTE_V` 位是否被设置）。
- 如果无效：
  - 当 `create` 为 `false` 或者页分配失败时（`alloc_page()` 返回 `NULL`），直接返回 `NULL`。
  - 否则：
    - 调用 `alloc_page()` 分配一个新的物理页来存储第二级页表。
    - 调用 `set_page_ref(page, 1)` 设置该页的引用计数为 1。
    - 获取新分配页的物理地址 `pa`，然后使用 `KADDR(pa)` 将其转换为内核虚拟地址。
    - 使用 `memset()` 将该页表清零，以确保初始状态。
    - 最后，将该页表的物理页号和权限标志（`PTE_U | PTE_V`）写入第一级页目录项中。

#### 第二级页目录查询

```c
pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
if (!(*pdep0 & PTE_V)) {
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL) {
        return NULL;
    }
    set_page_ref(page, 1);
    uintptr_t pa = page2pa(page);
    memset(KADDR(pa), 0, PGSIZE);
    *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
}
```

- `pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)]`：
  - 使用 `PDE_ADDR(*pdep1)` 获取第一级页目录项指向的物理地址，再通过 `KADDR()` 转换为内核虚拟地址，以访问第二级页目录。
  - `PDX0(la)` 是一个宏，用于从虚拟地址中提取第二级页目录的索引。
- `if (!(*pdep0 & PTE_V))`：
  - 检查第二级页目录项是否有效。
- 如果无效：
  - 当 `create` 为 `false` 或者页分配失败时，返回 `NULL`。
  - 否则，类似第一级页表的操作，分配一个新的物理页来存储页表项，并清零后更新到第二级页目录中。

#### 返回页表项地址

```c
return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
```

- `PDE_ADDR(*pdep0)` 获取第二级页目录项的物理地址，通过 `KADDR()` 转换为虚拟地址。
- 使用 `PTX(la)` 从虚拟地址中提取页表项索引，最后返回该页表项的地址。

#### 宏和函数

- **宏**：
  - `PDX1(la)`：获取第一级页目录索引。
  - `PDX0(la)`：获取第二级页目录索引。
  - `PTX(la)`：获取页表项索引。
  - `KADDR(pa)`：将物理地址转换为内核虚拟地址。
  - `PDE_ADDR(pde)`：获取页目录项中的物理地址部分。

- **函数**：
  - `alloc_page()`：分配一个新的物理页。
  - `set_page_ref(page, 1)`：设置页的引用计数。
  - `page2pa(page)`：将 `Page` 结构转换为物理地址。
  - `pte_create()`：根据物理页号和标志位创建页表项。

###  4.结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。

在 RISC-V 架构中，分页机制支持不同的分页模式，包括：
- **SV32**（32-bit 地址空间）：2 级页表。
- **SV39**（39-bit 地址空间）：3 级页表。
- **SV48**（48-bit 地址空间）：4 级页表。

####  `get_pte()` 函数中两段相似代码分析

这段函数中，`get_pte()` 函数包含两段形式相似的代码，分别用于访问第一级页目录（`pgdir[PDX1(la)]`）和第二级页目录（`pgdir[PDX0(la)]`）。

**相似代码段1**（处理第一级页目录）：
```c
pde_t *pdep1 = &pgdir[PDX1(la)];
if (!(*pdep1 & PTE_V)) {
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL) {
        return NULL;
    }
    set_page_ref(page, 1);
    uintptr_t pa = page2pa(page);
    memset(KADDR(pa), 0, PGSIZE);
    *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
}
```

**相似代码段2**（处理第二级页目录）：
```c
pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
if (!(*pdep0 & PTE_V)) {
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL) {
        return NULL;
    }
    set_page_ref(page, 1);
    uintptr_t pa = page2pa(page);
    memset(KADDR(pa), 0, PGSIZE);
    *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
}
```
两段代码分别对应一级页表、二级页表，由于它们只是等级上的不同、而结构完全相同，所以代码相似。都包括：获取对应页、不存在则创建、设置页属性及其内存状态、构造页表项。
SV32、SV39、SV48 等分页模式的工作原理基本一致，都是分级页表结构，每一级页表的访问方式相似。具体的区别在于页表的层数不同：
  - **SV32**：两级页表。
  - **SV39**：三级页表。
  - **SV48**：四级页表。
  
- **逻辑相似性**：
  - 对每一级页表都要执行相同的操作：
    1. 通过索引计算页目录项的地址。
    2. 检查页目录项是否有效（`PTE_V`）。
    3. 如果无效且 `create` 标志为 `true`，则分配新页。
    4. 更新页目录项以指向新分配的页。
  
- **抽象出的通用操作**：
  - 由于各级页表的访问逻辑相似，只是层级不同，因此这两段代码看起来非常相似。无论是访问第一级页目录还是第二级页目录，都需要按上述步骤执行。

### 5. 分析：将页表查找和创建合并是否合适？

目前，`get_pte()` 函数将页表项的 **查找** 和 **创建** 合并在一起，设计上是一种 **方便性** 的考虑，即在查找页表项时可以选择性地进行创建。但这种写法也有其优缺点：

#### 优点
- **性能优化**：减少了在创建和查找页表时的重复代码，避免了在调用查找函数后再调用创建函数的额外开销。

#### 缺点
- **功能耦合**：将两种功能合并在一起违反了“单一职责原则”（Single Responsibility Principle），使得函数的功能不够清晰。如果只需要查找页表项而不想创建页表项，调用此函数时的逻辑就变得复杂。
- **不易扩展**：如果以后要扩展不同的页表查找策略（例如只读模式或不同的权限检查），将查找和创建逻辑分开会更灵活。

我认为将页表查找和创建合并是合适的，查找虚拟地址对应页表项时有可能不存在页表项，所以每次都会有一个缺失检查，如果确实则会调用相对应的创建函数，本质上依旧是结合在一起的。


## 练习4：补充完成Clock页替换算法（需要编程）

### 算法设计与实现
  - 通过一个 `curr_ptr` 时钟指针循环遍历 `pra_list` 链表。该算法的核心思路是：
    1. 初始化时，`pra_list_head` 为空链表，`curr_ptr` 指向链表头。
    2. 每次添加页面时，将新页面加入链表尾部，同时将其 `visited` 标志置为 1，表示该页面已被访问。
    3. 在页面置换时，`curr_ptr` 逐页遍历链表：
        - 若某页面的 `visited` 标志为 0，则选中该页作为受害页（victim），并将其从链表中删除。
        - 若 `visited` 标志为 1，则将其置为 0，表示页面已被重新访问，并继续查找下一页。
    4. 最差情况下，`curr_ptr` 需要遍历整个链表一圈才能找到 victim。


#### 初始化部分（`_clock_init_mm` 函数）
- 初始化页面替换链表 `pra_list_head` 为空链表。
- 初始化当前指针 `curr_ptr`，初始时指向链表头部 `pra_list_head`。
- 将 `mm->sm_priv` 设为指向 `pra_list_head`，以便从 `mm_struct` 访问页面链表。

**改动内容：**
```c
static int _clock_init_mm(struct mm_struct *mm)
{     
    list_init(&pra_list_head); // 初始化页面链表
    curr_ptr = &pra_list_head; // curr_ptr 指向链表头
    mm->sm_priv = &pra_list_head; // mm->sm_priv 指向页面链表
    return 0;
}
```

#### 将页面映射为可交换（`_clock_map_swappable` 函数）
- 新加载的页面会被插入到链表的末尾。
- 将 `page->visited` 置为 1，表示该页面被访问过。

**改动内容：**
```c
static int _clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *entry = &page->pra_page_link;
    list_entry_t *head = mm->sm_priv;

    assert(entry != NULL && curr_ptr != NULL);
    
    // 将新页面插入到链表中 curr_ptr 前一个位置（相当于插入到链表末尾）
    list_add(list_prev(curr_ptr), entry);
    page->visited = 1; // 设置访问位为 1
    return 0;
}
```

#### 选择要换出的页面（`_clock_swap_out_victim` 函数）
- 使用 `Clock` 算法查找待换出的页面：
  - 遍历链表中的页面，如果 `page->visited` 为 0，则选择该页面作为 victim。
  - 如果 `page->visited` 为 1，则将其重置为 0，并继续遍历下一个页面。
- `curr_ptr` 指向链表中的下一个页面，为下一次页面替换做准备。

**改动内容：**
```c
static int _clock_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick)
{
    list_entry_t *head = mm->sm_priv;
    
    while (1) {
        if (curr_ptr == head) {
            curr_ptr = list_next(curr_ptr); // 如果指向链表头，则指向下一个页面
        }

        struct Page *page = le2page(curr_ptr, pra_page_link);
        
        // 如果访问位为 0，则选择此页面作为 victim
        if (page->visited == 0) {
            *ptr_page = page;
            curr_ptr = list_next(curr_ptr); // 更新 curr_ptr 指向下一个页面
            return 0;
        } else {
            // 如果访问位为 1，则重置访问位为 0
            page->visited = 0;
            curr_ptr = list_next(curr_ptr); // 继续检查下一个页面
        }
    }
    return 0;
}
```




### 算法优势与劣势
- **Clock 页替换算法**：
  - **优势**：是通过curr_ptr 时钟指针循环遍历整个链表，如果在上一轮中某页未被访问
过，就要将其选为victim。
  - **劣势**：clock算法需要循环遍历链表，最差的情况时，需要循环一轮整个链表；而FIFO只需要从队列出口取出一页即可。因此，Clock的算法时间复杂度相较高一些。





